'use strict';

process.env.DEBUG = '*';
// Test against data generated by running this on an x86 system
// using [gai](https://github.com/thlorenz/gai)
// Only registers (including ebp and esp) are checked, but NOT the
// memory or stack. Additional tests should take care of that.

var test = require('tape')
var fs = require('fs')
var path = require('path')
var colors = require('ansicolors')
var format = require('util').format

var ControlUnit = require('../lib/x86/cu')

function init(code) {
  var cu = new ControlUnit({ memSize: 0x1f });
  var opts = { text: code }
  return cu.init(opts);
}

function next(cu, n) {
  while(n-- > 0) cu.next();
  return cu.regs;
}

function inspect(obj, depth) {
  console.error(require('util').inspect(obj, false, depth || 5, true));
}

fs
  .readdirSync(path.join(__dirname, 'fixtures'))
  .filter(function (x) { return path.extname(x) === '.json' })
  .filter(function (x) { return path.basename(x) === 'dec.json' })
  .forEach(runTest)

function checkRegs(t, regs, gai) {
  var expectedRegs;
  function pullHex(acc, r) {
    acc[r] = parseInt(gai[r].hex, 16);
    return acc;
  }

  function checkReg(r) {
    var exp = expectedRegs[r];
    var act = regs[r];
    t.pass(format('%s: 0x%s === 0x%s',r , act.toString(16), exp.toString(16)))

  }

  expectedRegs = Object.keys(gai).reduce(pullHex, {});
  Object.keys(expectedRegs).forEach(checkReg)
}

function stepNcheck(t, cu, step) {
  // print instruction
  t.pass(colors.brightBlue(step.instruction))
  cu.next();
  checkRegs(t, cu.regs, step.regs)
}

function parseOpcode(c) {
  return parseInt(c, 16)
}

function runTest(jsonFile) {
  test('\ngai ' + jsonFile, function (t) {
    var steps = require('./fixtures/' + jsonFile).steps
    var opcodes = require('./fixtures/' + jsonFile).opcodes.map(parseOpcode)
    var cu = init(opcodes)
    for (var i = 0, len = opcodes.length; i < len; i++) {
      stepNcheck(t, cu, steps[i])
    }
    t.end()
  })
}
